<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Validation - RM Number Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px 10px 80px 10px; /* Added bottom padding for footer */
            color: #333;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            margin: 0 auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: #666;
            font-size: 0.9rem;
        }

        /* Manual Control Section */
        .manual-control-section {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .manual-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .manual-control-title {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .manual-control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 6px;
            max-height: 160px;
            overflow-y: auto;
        }

        .manual-control-item {
            background: white;
            border-radius: 6px;
            padding: 8px;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .machine-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .machine-label {
            font-weight: 600;
            font-size: 0.8rem;
            color: #333;
        }

        /* Toggle Switch Styling - Smaller for mobile */
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: #27ae60;
        }

        .toggle-switch:before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active:before {
            transform: translateX(20px);
        }

        .toggle-status {
            font-size: 0.65rem;
            text-align: center;
            padding: 1px 4px;
            border-radius: 6px;
            font-weight: 500;
            min-height: 16px;
            line-height: 14px;
        }

        .toggle-status.on {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }

        .toggle-status.off {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
        }

        .toggle-status.updating {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            animation: pulse-text 1s infinite;
        }

        @keyframes pulse-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Machine Status Display */
        .machine-status-section {
            background: rgba(240, 245, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .machine-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .machine-status-title {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e74c3c;
            display: inline-block;
            margin-left: 5px;
            transition: background 0.3s ease;
        }

        .connection-indicator.connected {
            background: #27ae60;
        }

        .connection-indicator.connecting {
            background: #f39c12;
            animation: pulse-dot 1s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .refresh-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .refresh-btn:hover {
            background: #5a6fd8;
        }

        .machine-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            transition: opacity 0.2s ease;
        }

        .machine-status-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .machine-status-item.ok {
            background: rgba(39, 174, 96, 0.1);
            border: 1px solid rgba(39, 174, 96, 0.3);
            color: #27ae60;
        }

        .machine-status-item.no {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .machine-status-item.unknown {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #f39c12;
        }

        .machine-id {
            font-weight: 600;
        }

        .status-indicator {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            text-transform: uppercase;
        }

        .status-loading {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 15px;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .captured-image {
            width: 100%;
            max-height: 300px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 15px;
            object-fit: cover;
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 15px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .upload-area:hover {
            border-color: #667eea;
        }

        .upload-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #ccc;
        }

        .upload-text {
            color: #666;
            font-size: 0.9rem;
        }

        .file-input {
            display: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            flex: 1;
            min-width: 120px;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-primary.blocked {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #667eea;
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .status {
            text-align: center;
            margin: 15px 0;
            font-size: 0.9rem;
            padding: 12px;
            border-radius: 10px;
            font-weight: 500;
            white-space: pre-wrap;
        }

        .status.loading {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .status.error {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }

        .status.success {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
        }

        .status.warning {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
        }

        .status.blocked {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 15px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .result-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
            position: relative;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .result-type {
            font-weight: 600;
            color: #333;
        }

        .confidence-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .result-text {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: #333;
            word-break: break-word;
            white-space: pre-wrap;
            min-height: 60px;
            cursor: pointer;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            transition: border-color 0.2s ease;
            margin-bottom: 10px;
        }

        .result-text:hover {
            border-color: #667eea;
        }

        .result-text:empty:before {
            content: "Tap here when text appears to copy...";
            color: #999;
            font-style: italic;
        }

        .copy-hint {
            text-align: center;
            font-size: 0.8rem;
            color: #666;
            margin-top: 8px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            z-index: 1000;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: #e74c3c;
        }

        .notification.warning {
            background: #f39c12;
        }

        .verification-info {
            background: rgba(39, 174, 96, 0.1);
            border: 1px solid rgba(39, 174, 96, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.85rem;
            color: #27ae60;
        }

        .verification-info.invalid {
            background: rgba(231, 76, 60, 0.1);
            border-color: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        /* Machine status blocked warning */
        .machine-blocked-warning {
            background: rgba(231, 76, 60, 0.1);
            border: 2px solid rgba(231, 76, 60, 0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { border-color: rgba(231, 76, 60, 0.4); }
            50% { border-color: rgba(231, 76, 60, 0.8); }
            100% { border-color: rgba(231, 76, 60, 0.4); }
        }

        .machine-blocked-warning .icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .machine-blocked-warning .title {
            font-weight: 600;
            color: #e74c3c;
            margin-bottom: 5px;
        }

        .machine-blocked-warning .message {
            color: #c0392b;
            font-size: 0.85rem;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            padding: 8px 0;
            text-align: center;
            font-size: 0.75rem;
            color: #666;
            z-index: 1000;
        }

        .footer .company-name {
            font-weight: 600;
            color: #667eea;
        }

        .footer .location {
            color: #888;
        }

        .footer .contact {
            color: #667eea;
            font-weight: 500;
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            .container {
                padding: 15px;
                margin: 5px;
                border-radius: 15px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                min-width: 100%;
            }

            .machine-status-grid {
                grid-template-columns: 1fr;
            }

            .manual-control-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 4px;
                max-height: 140px;
            }

            .manual-control-item {
                padding: 6px 8px;
            }

            .machine-label {
                font-size: 0.75rem;
            }

            .toggle-switch {
                width: 36px;
                height: 18px;
            }

            .toggle-switch:before {
                width: 14px;
                height: 14px;
            }

            .toggle-switch.active:before {
                transform: translateX(18px);
            }

            .toggle-status {
                font-size: 0.6rem;
                padding: 1px 3px;
                min-height: 14px;
                line-height: 12px;
            }

            .footer {
                font-size: 0.7rem;
                padding: 6px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Machine Validation</h1>
            <p>RM Number Detection & Manual Control</p>
        </div>

        <!-- Machine Status Section -->
        <div class="machine-status-section">
            <div class="machine-status-header">
                <span class="machine-status-title">
                    🏭 Machine Status
                    <span class="connection-indicator" id="connectionIndicator"></span>
                </span>
                <button class="refresh-btn" id="refreshStatusBtn" onclick="forceRefreshStatus()">
                    🔄 Refresh
                </button>
            </div>
            <div id="machineStatusDisplay" class="status-loading">
                Connecting to machine status...
            </div>
        </div>

        <div class="upload-section">
            <div id="capturedImageContainer"></div>
            
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <div class="upload-text">
                    🇮🇳 Upload Screenshot<br>
                    <small>Upload image with RM validation text</small>
                </div>
            </div>
            
            <input type="file" id="fileInput" class="file-input" accept="image/*">
        </div>

        <!-- Manual Relay Control Section -->
        <div class="manual-control-section">
            <div class="manual-control-header">
                <span class="manual-control-title">
                    Manual Control
                </span>
            </div>
            <div id="manualControlDisplay" class="status-loading">
                Loading manual controls...
            </div>
        </div>

        <div class="controls" id="controls">
            <button class="btn btn-primary" id="processBtn" style="display: none;">
                🔍 Scan RM Number
            </button>
            <button class="btn btn-secondary" id="retakeBtn" style="display: none;">
                🔄 Upload New
            </button>
        </div>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="status" id="status">Upload a screenshot to start scanning for RM validation</div>

        <div id="verificationInfo"></div>
    </div>

    <div class="notification" id="notification">✅ Processing complete!</div>

    <!-- Footer -->
    <div class="footer">
        <div>Powered by <span class="company-name">KL Technology Solutions</span></div>
        <div><span class="location">Attibele, Bangalore</span> | <span class="contact">📞 9900671351</span></div>
    </div>

    <script>
        // Global machine status storage
        let machineStatusData = {};
        let manualToggleData = {};
        let lastStatusUpdate = null;
        let refreshInterval = 3000; // Start with 3 seconds
        let consecutiveSuccesses = 0;
        let refreshTimer = null;

        // Server integration
        function getServerUrl() {
            return 'https://script.google.com/macros/s/AKfycbwyDKEPqPyEF2bf6znQLePNVW0DfuMDjXB5364yH-i-Aktz4xbdM_N3r_dLv3JMNEf42Q/exec';
        }
        
        function isAutoSendEnabled() {
            return true; // Always auto-send
        }

        // ===== MANUAL TOGGLE FUNCTIONS =====

        // Send manual toggle state to server
        async function sendManualToggle(machineId, toggleState) {
            try {
                const serverUrl = getServerUrl();
                
                const data = {
                    type: 'manual_toggle',
                    machineId: machineId,
                    toggleState: toggleState,
                    timestamp: new Date().toISOString()
                };
                
                console.log('Sending manual toggle:', data);
                
                const response = await fetch(serverUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                // Update local state immediately for better UX
                manualToggleData[machineId] = {
                    state: toggleState,
                    lastUpdate: new Date(),
                    updating: false
                };
                
                displayManualControls();
                
                showNotification(`🎮 Manual toggle for ${machineId} set to ${toggleState ? 'ON' : 'OFF'}`);
                return true;
                
            } catch (error) {
                console.error('Failed to send manual toggle:', error);
                showNotification('❌ Failed to send manual toggle', 'error');
                return false;
            }
        }

        // Handle toggle click
        function handleToggleClick(machineId) {
            const currentState = manualToggleData[machineId]?.state || false;
            const newState = !currentState;
            
            // Set updating state
            if (!manualToggleData[machineId]) {
                manualToggleData[machineId] = {};
            }
            manualToggleData[machineId].updating = true;
            displayManualControls();
            
            sendManualToggle(machineId, newState);
        }

        // Display manual control toggles
        function displayManualControls() {
            const display = document.getElementById('manualControlDisplay');
            
            const machineIds = Object.keys(machineStatusData);
            
            if (machineIds.length === 0) {
                display.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 15px;">
                        📊 No machines available for manual control<br>
                        <small style="color: #999;">Machine status must be loaded first</small>
                    </div>
                `;
                return;
            }
            
            const controlsHtml = machineIds
                .sort((a, b) => a.localeCompare(b))
                .map(machineId => {
                    const toggleData = manualToggleData[machineId] || { state: false, updating: false };
                    const isOn = toggleData.state;
                    const isUpdating = toggleData.updating;
                    
                    const toggleClass = isOn ? 'toggle-switch active' : 'toggle-switch';
                    const statusClass = isUpdating ? 'toggle-status updating' : (isOn ? 'toggle-status on' : 'toggle-status off');
                    const statusText = isUpdating ? 'Updating...' : (isOn ? 'ON' : 'OFF');
                    
                    return `
                        <div class="manual-control-item">
                            <div class="machine-toggle">
                                <span class="machine-label">${machineId}</span>
                                <div class="${toggleClass}" onclick="handleToggleClick('${machineId}')" ${isUpdating ? 'style="opacity: 0.6; cursor: wait;"' : ''}></div>
                            </div>
                            <div class="${statusClass}">
                                ${statusText}
                            </div>
                        </div>
                    `;
                }).join('');
            
            display.innerHTML = `
                <div class="manual-control-grid">
                    ${controlsHtml}
                </div>
                <div style="text-align: center; margin-top: 8px; font-size: 0.65rem; color: #666;">
                    Toggle switches to manually control relay states
                </div>
            `;
        }

        // Fetch machine status from server
        async function fetchMachineStatus() {
            try {
                showStatusLoading();
                
                const serverUrl = getServerUrl();
                
                // Try Apps Script endpoint first
                await tryAppsScriptStatus(serverUrl);
                
            } catch (error) {
                console.error('Failed to fetch machine status:', error);
                showStatusError(`Connection error: ${error.message}`);
                
                // Don't clear existing machine status data on error
                // Keep the data visible for user reference
                consecutiveSuccesses = 0;
            }
        }

        // Try to get machine status from Apps Script
        async function tryAppsScriptStatus(baseUrl) {
            try {
                // Try the Apps Script with machine status parameter
                const statusUrl = `${baseUrl}?action=get_machine_status&timestamp=${Date.now()}`;
                
                console.log('Trying Apps Script machine status:', statusUrl);
                
                const response = await fetch(statusUrl, {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    throw new Error(`Apps Script HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Apps Script response:', data);
                
                if (data.status === 'success' && data.machines) {
                    processMachineStatusData(data);
                    
                    // Also process manual toggle data if present
                    if (data.manualToggles) {
                        processManualToggleData(data.manualToggles);
                    }
                    
                    consecutiveSuccesses++;
                    adjustRefreshRate();
                    return;
                }
                
                throw new Error('No machine status endpoint available');
                
            } catch (error) {
                console.log('Apps Script status failed:', error.message);
                await tryDirectSheetsAccess(baseUrl);
            }
        }

        // Process manual toggle data from server
        function processManualToggleData(togglesArray) {
            if (Array.isArray(togglesArray)) {
                togglesArray.forEach(toggle => {
                    manualToggleData[toggle.machineId] = {
                        state: toggle.toggleState,
                        lastUpdate: new Date(toggle.lastUpdate),
                        updating: false
                    };
                });
            }
            displayManualControls();
        }

        // Try to read directly from Google Sheets
        async function tryDirectSheetsAccess(url) {
            const sheetsId = getSheetsIdFromUrl(url);
            if (!sheetsId) {
                throw new Error('Cannot read machine status - no server ID found and no Apps Script endpoint');
            }
            
            // Use Google Sheets CSV export URL for "Machine Status" sheet
            const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetsId}/gviz/tq?tqx=out:csv&sheet=Machine Status&headers=1&tq=SELECT A,B,C,D,E`;
            
            console.log('Trying direct server access:', csvUrl);
            
            const response = await fetch(csvUrl, {
                method: 'GET',
                mode: 'cors'
            });
            
            if (!response.ok) {
                throw new Error(`Server access failed HTTP ${response.status}. Create "Machine Status" sheet and make it publicly viewable.`);
            }
            
            const csvText = await response.text();
            console.log('Received CSV data:', csvText.substring(0, 200) + '...');
            
            // Parse CSV data
            const csvData = parseCSV(csvText);
            processMachineStatusFromCSV(csvData);
            consecutiveSuccesses++;
            adjustRefreshRate();
        }

        // Adaptive refresh rate management
        function adjustRefreshRate() {
            const minInterval = 1000; // 1 second minimum
            const maxInterval = 5000; // 5 seconds maximum
            const baseInterval = 3000; // 3 seconds base
            
            if (consecutiveSuccesses >= 10) {
                // After 10 successful fetches, slow down slightly
                refreshInterval = Math.min(maxInterval, baseInterval + 1000);
            } else if (consecutiveSuccesses >= 5) {
                // After 5 successful fetches, use optimal rate
                refreshInterval = baseInterval;
            } else {
                // For the first few fetches, go faster
                refreshInterval = Math.max(minInterval, baseInterval - 1000);
            }
            
            console.log(`Refresh rate adjusted: ${refreshInterval}ms (successes: ${consecutiveSuccesses})`);
        }

        // Reset refresh rate on errors
        function resetRefreshRate() {
            consecutiveSuccesses = 0;
            refreshInterval = 3000; // Reset to base 3 seconds
        }

        // Extract Google Sheets ID from URL (updated)
        function getSheetsIdFromUrl(url = null) {
            const targetUrl = url || getServerUrl();
            
            // Skip if it's an Apps Script URL
            if (targetUrl.includes('script.google.com')) {
                return null;
            }
            
            // Try to extract Sheets ID from various URL formats
            const patterns = [
                /\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/,
                /key=([a-zA-Z0-9-_]+)/,
                /id=([a-zA-Z0-9-_]+)/
            ];
            
            for (const pattern of patterns) {
                const match = targetUrl.match(pattern);
                if (match) {
                    console.log('Extracted Sheets ID:', match[1]);
                    return match[1];
                }
            }
            
            return null;
        }

        // Simple CSV parser
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                if (values.length >= headers.length && values[0]) { // Skip empty rows
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });
                    data.push(row);
                }
            }
            
            console.log('Parsed CSV data:', data);
            return data;
        }

        // Process machine status from CSV data
        function processMachineStatusFromCSV(csvData) {
            machineStatusData = {};
            
            csvData.forEach(row => {
                const machineId = row['Machine ID'] || row['machineId'] || row['Machine_ID'];
                const currentStatus = row['Current Status'] || row['currentStatus'] || row['Current_Status'];
                const pinState = row['Pin State'] || row['pinState'] || row['Pin_State'];
                const lastUpdate = row['Last Update'] || row['lastUpdate'] || row['Last_Update'];
                const cycles = row['Status Cycles'] || row['statusCycles'] || row['Status_Cycles'];
                
                if (machineId && machineId.trim() !== '') {
                    machineStatusData[machineId.trim()] = {
                        status: currentStatus || 'Unknown',
                        pinState: pinState || 'Unknown',
                        lastUpdate: lastUpdate,
                        cycles: parseInt(cycles) || 0
                    };
                }
            });
            
            console.log('Processed machine status data:', machineStatusData);
            lastStatusUpdate = new Date();
            displayMachineStatus();
            displayManualControls(); // Update manual controls when machine data changes
        }

        // Process machine status data from Apps Script
        function processMachineStatusData(data) {
            machineStatusData = {};
            
            // Convert array to object for easy lookup
            if (data.machines && Array.isArray(data.machines)) {
                data.machines.forEach(machine => {
                    machineStatusData[machine.machineId] = {
                        status: machine.currentStatus || 'Unknown',
                        pinState: machine.pinState || 'Unknown',
                        lastUpdate: machine.lastUpdate,
                        cycles: machine.statusCycles || 0
                    };
                });
            }
            
            console.log('Processed machine status data:', machineStatusData);
            lastStatusUpdate = new Date();
            displayMachineStatus();
            displayManualControls(); // Update manual controls when machine data changes
        }

        // Display machine status in the UI (smooth updates)
        function displayMachineStatus() {
            const display = document.getElementById('machineStatusDisplay');
            const indicator = document.getElementById('connectionIndicator');
            const section = document.querySelector('.machine-status-section');
            
            // Remove updating visual cues
            if (section) section.classList.remove('updating');
            
            if (Object.keys(machineStatusData).length === 0) {
                display.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 15px;">
                        📊 No machine data available<br>
                        <small style="color: #999;">Create "Machine Status" sheet or update Apps Script</small>
                    </div>
                `;
                indicator.className = 'connection-indicator'; // Red/disconnected
                return;
            }
            
            // Create the grid HTML
            const gridHtml = Object.entries(machineStatusData)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([machineId, data]) => {
                    const statusClass = data.status.toLowerCase() === 'ok' ? 'ok' : 
                                      data.status.toLowerCase() === 'no' ? 'no' : 'unknown';
                    const statusIcon = statusClass === 'ok' ? '✅' : 
                                     statusClass === 'no' ? '❌' : '⚠️';
                    
                    return `
                        <div class="machine-status-item ${statusClass}">
                            <span class="machine-id">${machineId}</span>
                            <span class="status-indicator">${statusIcon} ${data.status}</span>
                        </div>
                    `;
                }).join('');
            
            const updateTime = lastStatusUpdate ? 
                `Updated: ${lastStatusUpdate.toLocaleTimeString()} (${refreshInterval/1000}s refresh)` : 
                'Never updated';
            
            // Create the complete HTML
            const newHtml = `
                <div class="machine-status-grid">
                    ${gridHtml}
                </div>
                <div style="text-align: center; margin-top: 10px; font-size: 0.7rem; color: #666;">
                    ${updateTime}
                </div>
            `;
            
            // Only update if content has actually changed (prevents flickering)
            if (display.innerHTML !== newHtml) {
                display.innerHTML = newHtml;
            }
            
            // Remove any updating class from the new grid
            const newGrid = display.querySelector('.machine-status-grid');
            if (newGrid) newGrid.classList.remove('updating');
            
            // Set connection indicator to green (connected)
            indicator.className = 'connection-indicator connected';
        }

        // Force immediate refresh
        async function forceRefreshStatus() {
            console.log('Force refreshing machine status...');
            resetRefreshRate(); // Reset to ensure immediate update
            await fetchMachineStatus();
            
            // Restart the adaptive timer
            if (refreshTimer) {
                clearTimeout(refreshTimer);
            }
            initializeMachineStatus();
        }

        // Check if machine is blocked (status = "No")
        function isMachineBlocked(rmNumber) {
            const machineData = machineStatusData[rmNumber];
            if (!machineData) {
                console.log(`No status data for machine ${rmNumber} - allowing operation (no blocking data available)`);
                return false;
            }
            
            const isBlocked = machineData.status.toLowerCase() === 'no';
            console.log(`Machine ${rmNumber} status: ${machineData.status} - ${isBlocked ? 'BLOCKED' : 'ALLOWED'}`);
            return isBlocked;
        }

        // Show status loading (subtle visual feedback)
        function showStatusLoading() {
            const indicator = document.getElementById('connectionIndicator');
            const section = document.querySelector('.machine-status-section');
            const grid = document.querySelector('.machine-status-grid');
            
            // Show connecting indicator
            indicator.className = 'connection-indicator connecting';
            
            // Add subtle visual feedback
            if (section) section.classList.add('updating');
            if (grid) grid.classList.add('updating');
            
            // If no data exists yet, show loading message
            const display = document.getElementById('machineStatusDisplay');
            if (Object.keys(machineStatusData).length === 0) {
                display.innerHTML = '<div class="status-loading">🔄 Connecting to machine status...</div>';
            } else {
                // Keep existing data, just update the timestamp to show it's refreshing
                const timestampDiv = display.querySelector('div[style*="text-align: center"]');
                if (timestampDiv) {
                    timestampDiv.innerHTML = `🔄 Updating... (${refreshInterval/1000}s refresh)`;
                }
            }
        }

        // Show status error (preserve existing data when possible)
        function showStatusError(message) {
            const display = document.getElementById('machineStatusDisplay');
            const indicator = document.getElementById('connectionIndicator');
            const section = document.querySelector('.machine-status-section');
            const grid = document.querySelector('.machine-status-grid');
            
            // Remove updating visual cues
            if (section) section.classList.remove('updating');
            if (grid) grid.classList.remove('updating');
            
            // If we have existing data, keep it and just show error in status
            if (Object.keys(machineStatusData).length > 0) {
                // Keep existing machine data visible, just update the footer
                const existingGrid = display.querySelector('.machine-status-grid');
                if (existingGrid) {
                    // Update only the timestamp area to show error
                    const timestampDiv = display.querySelector('div[style*="text-align: center"]');
                    if (timestampDiv) {
                        timestampDiv.innerHTML = `
                            <div style="color: #e74c3c; font-size: 0.7rem;">
                                ❌ ${message}<br>
                                <button onclick="initializeMachineStatus()" 
                                        style="margin-top: 4px; background: #667eea; color: white; border: none; padding: 3px 8px; border-radius: 4px; font-size: 0.65rem; cursor: pointer;">
                                    🔄 Retry
                                </button>
                            </div>
                        `;
                    }
                    indicator.className = 'connection-indicator'; // Red/disconnected
                    resetRefreshRate();
                    return;
                }
            }
            
            // If no existing data, show full error message
            display.innerHTML = `
                <div style="color: #e74c3c; text-align: center; padding: 15px;">
                    ❌ ${message}<br>
                    <button onclick="initializeMachineStatus()" 
                            style="margin-top: 8px; background: #667eea; color: white; border: none; padding: 4px 12px; border-radius: 6px; font-size: 0.75rem; cursor: pointer;">
                        🔄 Retry Now
                    </button>
                </div>
            `;
            indicator.className = 'connection-indicator'; // Red/disconnected
            resetRefreshRate();
        }

        // Show machine blocked warning
        function showMachineBlockedWarning(rmNumber) {
            const verificationInfo = document.getElementById('verificationInfo');
            verificationInfo.innerHTML = `
                <div class="machine-blocked-warning">
                    <div class="icon">🚫</div>
                    <div class="title">Machine ${rmNumber} is BLOCKED</div>
                    <div class="message">Machine status is "No" - RM scanning blocked until status returns to "ok"</div>
                </div>
            `;
        }
        
        // Convert to Indian Standard Time (IST)
        function convertToIST(date) {
            const istOffset = 5.5 * 60 * 60 * 1000; // 5.5 hours in milliseconds
            const utcTime = date.getTime() + (date.getTimezoneOffset() * 60000);
            return new Date(utcTime + istOffset);
        }
        
        // Extract RM number and timestamp from OCR text
        function extractRMValidation(text) {
            console.log('=== EXTRACTING RM VALIDATION ===');
            console.log('OCR Text:', text);
            
            // Pattern: Valid RM OK FOR USE - (64-2) (15-07-25,02:47 PM)
            const patterns = [
                /Valid\s+RM\s+OK\s+FOR\s+USE\s*-\s*\(([^)]+)\)\s*\(([^)]+)\)/i,
                /Valid\s+RM\s+0K\s+FOR\s+USE\s*-\s*\(([^)]+)\)\s*\(([^)]+)\)/i,
                /Valid\s+RM\s+[O0]K\s+FOR\s+USE\s*-\s*\(([^)]+)\)\s*\(([^)]+)\)/i,
                /RM\s+[O0]K\s+FOR\s+USE\s*-\s*\(([^)]+)\)\s*\(([^)]+)\)/i,
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match && match[1] && match[2]) {
                    const rmNumber = match[1].trim();
                    const timestampStr = match[2].trim();
                    
                    console.log('Found RM Number:', rmNumber);
                    console.log('Found Timestamp:', timestampStr);
                    
                    return {
                        rmNumber: rmNumber,
                        timestampStr: timestampStr,
                        fullMatch: match[0]
                    };
                }
            }
            
            console.log('No valid RM validation pattern found');
            return null;
        }
        
        // Parse timestamp from text format: "15-07-25,02:47 PM" or "16-07-25,23:10 PM" (OCR errors)
        function parseTimestamp(timestampStr) {
            console.log('=== PARSING TIMESTAMP ===');
            console.log('Input:', timestampStr);
            
            // Enhanced patterns to handle OCR errors and multiple formats
            const timestampPatterns = [
                // Standard 12-hour format: DD-MM-YY,HH:MM AM/PM
                {
                    pattern: /(\d{1,2})-(\d{1,2})-(\d{2}),(\d{1,2}):(\d{2})\s*(AM|PM)/i,
                    type: '12hour'
                },
                // Alternative separators
                {
                    pattern: /(\d{1,2})\/(\d{1,2})\/(\d{2}),(\d{1,2}):(\d{2})\s*(AM|PM)/i,
                    type: '12hour'
                },
                {
                    pattern: /(\d{1,2})\.(\d{1,2})\.(\d{2}),(\d{1,2}):(\d{2})\s*(AM|PM)/i,
                    type: '12hour'
                },
                // 24-hour format without AM/PM (in case OCR misses it)
                {
                    pattern: /(\d{1,2})-(\d{1,2})-(\d{2}),(\d{1,2}):(\d{2})/,
                    type: '24hour'
                },
                {
                    pattern: /(\d{1,2})\/(\d{1,2})\/(\d{2}),(\d{1,2}):(\d{2})/,
                    type: '24hour'
                }
            ];
            
            for (const patternObj of timestampPatterns) {
                const match = timestampStr.match(patternObj.pattern);
                if (match) {
                    let day, month, year, hour, minute, ampm;
                    
                    if (patternObj.type === '12hour') {
                        [, day, month, year, hour, minute, ampm] = match;
                    } else {
                        [, day, month, year, hour, minute] = match;
                        ampm = null;
                    }
                    
                    day = parseInt(day);
                    month = parseInt(month) - 1; // JavaScript months are 0-based
                    year = parseInt(year);
                    hour = parseInt(hour);
                    minute = parseInt(minute);
                    
                    console.log('Raw parsed:', {day, month: month+1, year, hour, minute, ampm, type: patternObj.type});
                    
                    // Handle OCR errors where 24-hour time has AM/PM (like "23:10 PM")
                    if (ampm && hour > 12) {
                        console.log('⚠️ OCR Error detected: 24-hour time with AM/PM, treating as 24-hour format');
                        // Ignore AM/PM for hours > 12, treat as 24-hour format
                        ampm = null;
                    }
                    
                    // Convert 12-hour to 24-hour format if needed
                    if (ampm) {
                        if (ampm.toUpperCase() === 'PM' && hour !== 12) {
                            hour += 12;
                        } else if (ampm.toUpperCase() === 'AM' && hour === 12) {
                            hour = 0;
                        }
                    }
                    
                    // Assume 20XX for 2-digit years
                    if (year < 50) {
                        year += 2000;
                    } else if (year < 100) {
                        year += 1900;
                    }
                    
                    console.log('Final parsed components:', {day, month: month+1, year, hour, minute});
                    
                    // Validate components
                    if (month >= 0 && month <= 11 && 
                        day >= 1 && day <= 31 && 
                        hour >= 0 && hour <= 23 && 
                        minute >= 0 && minute <= 59) {
                        
                        const parsedDate = new Date(year, month, day, hour, minute, 0);
                        console.log('✅ Valid timestamp parsed:', parsedDate);
                        return parsedDate;
                    } else {
                        console.log('❌ Invalid date components after parsing');
                    }
                }
            }
            
            console.log('❌ Failed to parse timestamp - no pattern matched');
            return null;
        }
        
        // Verify RM validation with timestamp check
        function verifyRMValidation(rmData) {
            console.log('=== VERIFYING RM VALIDATION ===');
            
            if (!rmData) {
                return {
                    valid: false,
                    reason: '❌ No valid RM validation pattern found in text',
                    rmNumber: null,
                    timeDiff: null
                };
            }
            
            const { rmNumber, timestampStr, fullMatch } = rmData;
            const currentTimeIST = convertToIST(new Date());
            
            // Check if machine is blocked FIRST
            if (isMachineBlocked(rmNumber)) {
                return {
                    valid: false,
                    blocked: true,
                    reason: `🚫 Machine ${rmNumber} is BLOCKED (status: "No")`,
                    rmNumber: rmNumber,
                    timeDiff: null
                };
            }
            
            // Parse the timestamp from the OCR text
            const ocrTimestamp = parseTimestamp(timestampStr);
            
            if (!ocrTimestamp) {
                return {
                    valid: false,
                    reason: `❌ Could not parse timestamp: "${timestampStr}"`,
                    rmNumber: rmNumber,
                    timeDiff: null
                };
            }
            
            // Convert OCR timestamp to IST (assuming it's already in IST)
            const ocrTimeIST = convertToIST(ocrTimestamp);
            
            // Calculate time difference in minutes
            const timeDiffMs = currentTimeIST.getTime() - ocrTimeIST.getTime();
            const timeDiffMinutes = timeDiffMs / (1000 * 60);
            
            console.log('Current IST:', currentTimeIST);
            console.log('OCR Time IST:', ocrTimeIST);
            console.log('Time difference (minutes):', timeDiffMinutes);
            
            // Check if within 2 minutes
            const isValid = timeDiffMinutes >= 0 && timeDiffMinutes <= 2;
            
            const result = {
                valid: isValid,
                blocked: false,
                reason: isValid ? 
                    `✅ Verified: RM ${rmNumber} within 2min limit (${Math.round(timeDiffMinutes * 10) / 10}min ago)` :
                    timeDiffMinutes < 0 ?
                        `❌ Future timestamp detected (${Math.abs(Math.round(timeDiffMinutes * 10) / 10)}min ahead)` :
                        `❌ Timestamp too old (${Math.round(timeDiffMinutes * 10) / 10}min ago, limit: 2min)`,
                rmNumber: rmNumber,
                timeDiff: Math.round(timeDiffMinutes * 10) / 10,
                ocrTime: ocrTimeIST,
                currentTime: currentTimeIST,
                fullMatch: fullMatch
            };
            
            console.log('Verification result:', result);
            return result;
        }
        
        // Send data to server (now checks machine status)
        async function sendToServer(rmNumber, fullText) {
            try {
                // Double-check machine status before sending
                if (isMachineBlocked(rmNumber)) {
                    showNotification(`🚫 Machine ${rmNumber} is BLOCKED - Cannot send to server`, 'error');
                    showStatus(`Machine ${rmNumber} is blocked (status: "No"). RM not sent to server.`, 'blocked');
                    return false;
                }
                
                const serverUrl = getServerUrl();
                showStatus('Sending to server...', 'loading');
                
                const data = {
                    rmNumber: String(rmNumber).trim(),
                    fullText: String(fullText).trim(),
                    timestamp: new Date().toISOString()
                };
                
                console.log('Sending to server:', data);
                
                await fetch(serverUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                showNotification(`📊 RM ${rmNumber} sent to server!`);
                showStatus(`Success! RM ${rmNumber} logged to server.`, 'success');
                return true;
                
            } catch (error) {
                console.error('Failed to send to server:', error);
                showNotification('❌ Failed to send to server', 'error');
                showStatus('Failed to send to server. Check console for details.', 'error');
                return false;
            }
        }

        // UI Elements
        const processBtn = document.getElementById('processBtn');
        const retakeBtn = document.getElementById('retakeBtn');
        const status = document.getElementById('status');
        const capturedImageContainer = document.getElementById('capturedImageContainer');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const notification = document.getElementById('notification');
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const verificationInfo = document.getElementById('verificationInfo');

        // State variables
        let capturedImageData = null;
        let imageAlreadyProcessed = false;
        let processedImageHash = null;

        // Image processing state management
        function generateImageHash(imageData) {
            const dataStr = imageData.toString();
            const hash = dataStr.length + dataStr.slice(0, 100) + dataStr.slice(-100);
            return btoa(hash).slice(0, 16);
        }
        
        function isCurrentImageProcessed() {
            if (!capturedImageData || !processedImageHash) return false;
            const currentHash = generateImageHash(capturedImageData);
            return currentHash === processedImageHash;
        }
        
        function markImageAsProcessed() {
            if (capturedImageData) {
                processedImageHash = generateImageHash(capturedImageData);
                imageAlreadyProcessed = true;
                processBtn.disabled = true;
                processBtn.style.opacity = '0.5';
                processBtn.innerHTML = '✅ Already Scanned';
            }
        }
        
        function resetProcessingState() {
            imageAlreadyProcessed = false;
            processedImageHash = null;
            processBtn.disabled = false;
            processBtn.style.opacity = '1';
            processBtn.innerHTML = '🔍 Scan RM Number';
            processBtn.classList.remove('blocked');
        }

        // File upload handling
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileUpload(e.target.files[0]);
            }
        });

        async function handleFileUpload(file) {
            if (!file.type.startsWith('image/')) {
                showStatus('❌ Please select an image file (JPG, PNG, etc.)', 'error');
                return;
            }

            resetProcessingState();
            showStatus('📊 Loading image...', 'loading');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                capturedImageData = e.target.result;
                displayCapturedImage(capturedImageData);
                showProcessControls();
                showStatus('✅ Image ready for scanning', 'success');
            };
            
            reader.onerror = () => {
                showStatus('❌ Failed to read file. Please try again.', 'error');
            };
            
            reader.readAsDataURL(file);
        }

        processBtn.addEventListener('click', async () => {
            if (!capturedImageData) return;
            
            if (imageAlreadyProcessed || isCurrentImageProcessed()) {
                showNotification('⚠️ This image was already scanned! Upload a new image.', 'warning');
                showStatus('Image already processed. Please upload a new image to scan again.', 'warning');
                return;
            }
            
            await performOCR();
        });

        retakeBtn.addEventListener('click', () => {
            reset();
        });

        // UI Functions
        function displayCapturedImage(imageData) {
            const img = document.createElement('img');
            img.src = imageData;
            img.className = 'captured-image';
            capturedImageContainer.innerHTML = '';
            capturedImageContainer.appendChild(img);
            uploadArea.style.display = 'none';
        }

        function showProcessControls() {
            processBtn.style.display = 'block';
            retakeBtn.style.display = 'block';
            
            if (!imageAlreadyProcessed) {
                processBtn.disabled = false;
                processBtn.style.opacity = '1';
                processBtn.innerHTML = '🔍 Scan RM Number';
            }
        }

        function reset() {
            capturedImageContainer.innerHTML = '';
            uploadArea.style.display = 'block';
            
            processBtn.style.display = 'none';
            retakeBtn.style.display = 'none';
            
            capturedImageData = null;
            resetProcessingState();
            showStatus('Upload a screenshot to start scanning for RM validation', '');
        }

        // Image preprocessing for better OCR
        function preprocessImage(imageData, options = {}) {
            const { contrast = 1.0, brightness = 0, mode = 'subtle' } = options;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const img = new Image();
            
            return new Promise((resolve) => {
                img.onload = () => {
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    tempCtx.drawImage(img, 0, 0);
                    
                    if (mode === 'sharp') {
                        tempCtx.filter = `contrast(${contrast}) brightness(${100 + brightness}%) saturate(0%) blur(0px)`;
                        tempCtx.drawImage(tempCanvas, 0, 0);
                    } else if (mode === 'blue-enhance') {
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        const data = imageData.data;
                        
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            const isBlueish = b > r && b > g && b > 100;
                            
                            if (isBlueish) {
                                data[i] = Math.min(r * 0.3, 50);
                                data[i + 1] = Math.min(g * 0.3, 50);
                                data[i + 2] = Math.min(b * 0.5, 80);
                            } else {
                                data[i] = Math.min(255, r * 1.4);
                                data[i + 1] = Math.min(255, g * 1.4);
                                data[i + 2] = Math.min(255, b * 1.2);
                            }
                        }
                        
                        tempCtx.putImageData(imageData, 0, 0);
                    } else {
                        tempCtx.filter = `contrast(${contrast}) brightness(${100 + brightness}%)`;
                        tempCtx.drawImage(tempCanvas, 0, 0);
                    }
                    
                    resolve(tempCanvas.toDataURL('image/png', 0.95));
                };
                img.src = imageData;
            });
        }

        // Advanced OCR functionality
        async function performOCR() {
            if (!capturedImageData) return;
            
            try {
                processBtn.disabled = true;
                showProgress(true);
                
                const language = 'eng'; // Hardcoded to English
                
                showStatus('Processing...', 'loading');
                
                // Generate preprocessed variations
                const variations = [
                    { name: 'Original', data: capturedImageData },
                    { name: 'Enhanced', data: await preprocessImage(capturedImageData, { contrast: 1.2, brightness: 5 }) },
                    { name: 'Sharp', data: await preprocessImage(capturedImageData, { contrast: 1.3, brightness: 5, mode: 'sharp' }) },
                    { name: 'High Contrast', data: await preprocessImage(capturedImageData, { contrast: 1.8, brightness: 15 }) }
                ];

                const psmModes = ['3', '6', '11'];
                let bestResult = { text: '', confidence: 0 };
                let totalAttempts = variations.length * psmModes.length;
                let completedAttempts = 0;

                // Try OCR on each variation
                for (const variation of variations) {
                    for (const currentPsm of psmModes) {
                        try {
                            const worker = await Tesseract.createWorker(language, 1, {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        const progress = Math.round(m.progress * 100);
                                        const baseProgress = (completedAttempts / totalAttempts) * 100;
                                        const currentProgress = (m.progress / totalAttempts) * 100;
                                        const totalProgress = Math.round(baseProgress + currentProgress);
                                        updateProgress(totalProgress);
                                        showStatus(`Processing... ${progress}%`, 'loading');
                                    }
                                }
                            });
                            
                            await worker.setParameters({
                                tessedit_pageseg_mode: currentPsm,
                                tessedit_ocr_engine_mode: '1',
                                preserve_interword_spaces: '1'
                            });
                            
                            const { data } = await worker.recognize(variation.data);
                            await worker.terminate();
                            
                            const result = {
                                variation: `${variation.name} (PSM ${currentPsm})`,
                                text: data.text.trim(),
                                confidence: data.confidence
                            };
                            
                            // Enhanced scoring - prioritize RM validation detection
                            const rmData = extractRMValidation(result.text);
                            const containsRM = rmData !== null;
                            const adjustedScore = containsRM ? result.confidence + 20 : result.confidence;
                            
                            if (adjustedScore > bestResult.confidence && result.text.length > 0) {
                                bestResult = result;
                                bestResult.adjustedScore = adjustedScore;
                                bestResult.rmData = rmData;
                            }
                            
                            completedAttempts++;
                            
                        } catch (error) {
                            console.error(`Error with ${variation.name} PSM ${currentPsm}:`, error);
                            completedAttempts++;
                        }
                    }
                }

                // Display results
                if (bestResult.text) {
                    // Verify RM validation (includes machine status check)
                    const verification = verifyRMValidation(bestResult.rmData);
                    displayVerificationInfo(verification);
                    
                    if (verification.blocked) {
                        // Machine is blocked - show warning and block sending
                        showStatus(`🚫 Machine ${verification.rmNumber} is BLOCKED (status: "No")`, 'blocked');
                        showMachineBlockedWarning(verification.rmNumber);
                        markImageAsProcessed();
                        
                        // Update process button to show blocked state
                        processBtn.classList.add('blocked');
                        processBtn.innerHTML = '🚫 Machine Blocked';
                        
                    } else if (verification.valid) {
                        showStatus(`✅ RM ${verification.rmNumber} verified and ready!`, 'success');
                        
                        markImageAsProcessed();
                        
                        // Auto-send if enabled (and not blocked)
                        if (isAutoSendEnabled()) {
                            setTimeout(() => {
                                sendToServer(verification.rmNumber, verification.fullMatch);
                            }, 1000);
                        }
                    } else {
                        showStatus('⚠️ RM validation failed - check timestamp or format', 'warning');
                    }
                } else {
                    showStatus('❌ No text detected in image', 'error');
                }
                
            } catch (error) {
                console.error('OCR Error:', error);
                showStatus('Processing failed. Please try again.', 'error');
            } finally {
                showProgress(false);
                processBtn.disabled = false;
            }
        }

        function displayVerificationInfo(verification) {
            if (!verification) return;
            
            verificationInfo.innerHTML = '';
            
            if (verification.blocked) {
                // Show machine blocked warning
                showMachineBlockedWarning(verification.rmNumber);
            } else {
                // Show normal verification info
                const infoDiv = document.createElement('div');
                infoDiv.className = verification.valid ? 'verification-info' : 'verification-info invalid';
                infoDiv.textContent = verification.reason;
                verificationInfo.appendChild(infoDiv);
            }
            
            // Scroll verification info into view if it contains content
            if (verificationInfo.innerHTML.trim() !== '') {
                verificationInfo.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function showStatus(message, type = '') {
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function showProgress(show) {
            progressBar.style.display = show ? 'block' : 'none';
            if (!show) progressFill.style.width = '0%';
        }

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            setTimeout(() => notification.classList.remove('show'), 3000);
        }

        // Initialize machine status monitoring with adaptive refresh
        async function initializeMachineStatus() {
            console.log('Initializing machine status monitoring with adaptive refresh...');
            
            // Clear any existing timer
            if (refreshTimer) {
                clearInterval(refreshTimer);
            }
            
            // Fetch initial status
            await fetchMachineStatus();
            
            // Set up adaptive refresh timer
            function scheduleNextRefresh() {
                if (refreshTimer) {
                    clearTimeout(refreshTimer);
                }
                
                refreshTimer = setTimeout(async () => {
                    try {
                        await fetchMachineStatus();
                        scheduleNextRefresh(); // Schedule next refresh
                    } catch (error) {
                        console.error('Refresh failed:', error);
                        resetRefreshRate();
                        scheduleNextRefresh(); // Keep trying
                    }
                }, refreshInterval);
            }
            
            // Start the refresh cycle
            scheduleNextRefresh();
            
            console.log(`Machine status monitoring started with ${refreshInterval}ms refresh rate`);
        }

        // Initialize application
        showStatus('Upload a screenshot to start scanning for RM validation', '');

        // Start machine status monitoring when page loads
        window.addEventListener('load', () => {
            console.log('Page loaded - starting machine status monitoring');
            initializeMachineStatus();
        });
    </script>
</body>
</html>
